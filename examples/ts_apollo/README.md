# ts-apollo

## Stack

- [TypeScript](https://www.typescriptlang.org/)
- [Apollo Server](https://www.apollographql.com/docs/apollo-server)

## DevOps

### Database / Models

Using [Prisma](https://www.prisma.io/docs/getting-started) as the ORM.

#### History of Commands

```bash
yarn add -D prisma
npx prisma init
```

Created new database in `psql` using the one generated by `examples/rails`.

```sql
create database ts_apollo_development;
```

Generate the first _Prisma_ skeleton using existing structure.

```bash
npx prisma db pull
```

## Solving N+1

Not implemented yet.

### Potential solutions within this stack

- [Prisma](https://www.prisma.io/)
  - TODO: Find a way to solve N+1 with _Prisma_
- [Sequelize](https://sequelize.org/) + [sequelize-proxy](https://github.com/oney/sequelize-proxy)
  - ðŸ›‘ Its generated code (from its CLI) do not play well with the current TS setup of this project
  - https://dev.to/zipy/sequelize-and-typescript-integration-a-practical-tutorial-5ha3

### Potential solutions in other stacks

- https://www.scalablepath.com/full-stack/graphql-api-full-stack-tutorial-part-1
  - https://www.graphile.org/postgraphile/performance/
- https://hackernoon.com/the-easiest-way-to-solve-n1-problem-on-graphql-s8283tgz

## Problems & Solutions

### Generated Type Force Complete Resolution Of Objects

By default, the types generated are "complete", meaning that for the GraphQL type `User!`, every field has to be resolved directly in the generator method. However, _Apollo Server_ allows a type to be resolved by its resolver class. Example: the root query resolver has a `user(id: ID!): User!` attribute, and a `User` has `posts: [Post!]!`. The generated types will force you to provide the `posts` values. Doing so at the root level is not desired, as we do not even know if that information was selected in the actual query. _Apollo Server_ allows those attribute to simply not be defined, telling it to go to the next resolver step in the chain (example: `const userResolvers: UserResolvers`).

For this to work properly with the _TypeScript_ generated types, we should be allowed to return a `Partial<User>` without failing to type-check.

See [this section](https://the-guild.dev/blog/better-type-safety-for-resolvers-with-graphql-codegen#whats-next) of the `graphql-codegen` documentation. In `codegen.ts` (or `.yaml` or `.js` or `.json`), inside of the `config` element, add `defaultMapper: 'Partial<{T}>'`.

See [this _StackOverflow_ post](https://stackoverflow.com/questions/77511383/forced-to-specify-relation-values-in-resolvers-with-apolloserver-and-typescript/77558629#77558629) for more.

### Using Partial Resolver Return Types Is Still Not Enough For Mutation Return Types

```graphql
type LogInResult {
  token: String!
  user: User!
}

type Mutation {
  logIn(input: LogInInput!): LogInResult!
}
```
The resolver for mutation `logIn`, by using `defaultMapper: 'Partial<{T}>'`, would then have to return

```ts
Partial<{
  token: string,
  user: User
}>
```

The problem repeats itself, just one level down. The `User` we return here should not resolve `posts` and `reactions` and leave that to the resolver chain.

Solution is to switch to `DeepPartial`, which is sadly not a part of the _TypeScript_ standard library.

```bash
yarn add -D utility-types
```

And then modify `codegen.ts`.

```ts
const config: CodegenConfig = {
  // ...
  generates: {
    'src/__generated__/graphql.ts': {
      plugins: [
        // ... add this plugin to import the proper lib
        { add: { content: "import { DeepPartial } from 'utility-types';" } },
      ],
      config: {
        // ... change the default mapper to `DeepPartial` instead of `Partial`
        defaultMapper: 'DeepPartial<{T}>',
      },
    }
  };
// ...
```

### Generate Types For Enum Don't Play Well With Prisma

In order to align the types generated by both _GraphQL Codegen_ (for _Apollo Server_) and _Prisma_, I needed to ensure 2 things.

In `codegen.ts`, in the `config` object, use `enumsAsConst: true` to tell _GraphQL Codegen_ to generate a `const object ...  as const` instead of a _TypeScript_ `enum`.

Originally, I created the database `enum` (_Prisma_) with lowercase values (personal standard), and defined the _GraphQL_ `enum` values in with uppercase values (observer _GraphQL_ standard). I changed the database to save them the same way I server them with _GraphQL_ â€“Â all uppercase â€“ so now there is no conversion needed, and the generated types from both sides play well together.
